- 虚函数与构造、析构函数
	- 构造函数不能为虚：对象构造时尚未形成虚表
	- 析构函数建议为虚：可以各类链式调用正确释放内存

- 虚析构函数与非虚对比

| 析构函数类型 | 行为例(Base* p = new Derived())                         | 风险       |
| ------ | ---------------------------------------------------- | -------- |
| 非虚析构函数 | `delete p`仅调用`~Base()`                               | 派生类资源泄露  |
| 虚析构函数  | `delete p`会调用`~Derived()`再在其内部进一步调用`~Base()`（这里是自动的） | 安全释放所有资源 |

- 纯虚析构函数
`virtual ~AbstractBase() = 0;`
必须在类外再定义（这里为了声明纯虚已经没有定义的空间了，而**析构函数无论非虚、虚、纯虚都需要定义的**，只需在类外部声明`AbstractBase::~AbstractBase() {}`即可（可以写成空的，但必须存在）
- **无论基类析构函数是否为虚函数，派生类析构函数执行完毕后，会自动调用基类析构函数。**（虚、纯虚都是）