##### 声明：
```cpp
template<typename T>
class ...
```
- 其主要表示类中的成员的数据类型不具体确定
- 而类中T必须被使用（于成员参量或成员函数参数均可）（`Tclass<int>`与`Tclass<double>`实例化后是两个不同的类）

#### 注意事项
- 类模板没有自动类型推导的使用方式(只能显示指定类型)：
```cpp
TClass a("123",100); //错，不会自动推类型
TClass<std::string, int> a("123",100); //对
```
- 类模板在模板参数列表中可以有默认参数
	（函数模板是不行的）
```cpp
template<typename T1,typename T2 = int>
class TClass{...};
TClass<std::string> b("123",100)
```
#### 类模板的成员函数
类模板的成员函数都是函数模板，实现语法和函数模板的类似。如果在类中定义（作为inline 函数），则不需要特别声明；如果在类外定义，则每个成员函数定义都要冠以模板参数说明，并 且在指定类名时要后跟类属参数。
也就是：
`Tclass<T>::func(...){...}`
即使类模板的成员函数**完全不使用模板参数 `T`**（在参数、返回值、函数体中均未涉及 `T`），在类外定义时，**仍然必须冠以模板参数说明**（`template <typename T>`），并且类名需要带模板参数（`Tclass<T>::`）。

这之中的原因分析与深层次理解：
1. **模板成员函数的归属**：  
    类模板的成员函数本质上属于模板的一部分，即使函数逻辑与 `T` 无关，其定义也必须与模板绑定。编译器需要明确该函数属于哪个模板实例化的作用域。
2. **实例化机制**：  
    成员函数的代码生成依赖于模板实例化。当类模板被实例化为具体类（如 `Array<int>`）时，其成员函数也会被实例化为具体函数（如 `Array<int>::printSize()`）。若缺少模板声明，编译器无法正确关联成员函数与模板类。
3. **语法规则**：  
    C++ 标准规定，类模板的成员函数在类外定义时，必须显式声明模板参数。这与函数是否使用 `T` 无关，是语法上的强制要求。

类模板中成员函数的创建时机：
	普通类成员函数一开始就创建
	类模板成员函数被调用时才创建（刚开始没法确定数据类型）

#### 模板类与类模板
- 类模板是泛型定义（`Array<T>`），模板类是实例化的具体类（`Array<int>`）。
- 类模板通过类型参数化实现代码复用，模板类是编译器生成的最终代码。