#### 模板必须要确定出T的数据类型才能使用
```cpp 
//Eg. 1
template<typename T>
void func1(const T&a){
	std::cout << "123";
}
//Eg. 2
template<typename T>
void func2(){
	std::cout << "123";
}

func1(a) //√
func2() //×
```

这里func2函数是确定不了数据类型的，因而模板没法实例化（完全没用到它）；而func1虽然函数体内没用到但是传参时可以确定而没事
对func2可以通过显式指定类型再正常使用（是如`func2<int>()`而不是`func2<>`）

#### 普通函数与函数模板：区别与使用顺序

区别：
1. 普通函数使用时可以发生自动类型转换（隐式类型转换）
2. 函数模板调用前如果利用了自动类型推导则不会发生隐式类型转换
3. 如果函数模板调用时显式指定类型，则可以发生隐式类型转换

调用规则
1. 如果函数模板与普通函数都可以实现，则优先调用普通函数
2. 可以通过空模板函数列表来调用函数模板（`func<>()`中的`<>`部分）
3. 如果函数模板可以产生更好的匹配则有点调用函数模板