#### 基本介绍
提供了一种统一且安全的方式访问和操作容器中的元素。通过抽象容器内部实现细节，迭代器使得算法可以独立于容器类型，极大提升了代码的复用性和灵活性。
（和for循环对比，由于vector、list等之间的构造其实是极不同的，迭代器提供了一种统一的操作方式，且使用时不用考虑指针等符号的问题

#### 本质
迭代器是一种类指针对象，支持对容器元素的遍历和访问。其核心功能包括：
- 解引用：访问当前元素（`*iter`）。
- 移动：指向下一个或上一个元素（`++iter`、`--iter`）。
- 比较：判断迭代器是否指向同一位置（`iter1 == iter2`）。

#### 与指针的异同
- 相似性：支持类似指针的操作（如`*`、`++`）。
- 差异性：
  - 迭代器是类对象，可封装复杂逻辑（如边界检查）。
  - 类型与容器绑定，保证类型安全。

#### 迭代器的分类
STL定义了5种迭代器，按功能从弱到强排列：

| 迭代器类型          | 支持操作                              | 适用容器示例               |
|---------------------|--------------------------------------|--------------------------|
| **输入迭代器**      | 只读，单向遍历（`++`）               | `istream`                |
| **输出迭代器**      | 只写，单向遍历                       | `ostream`                |
| **正向迭代器**      | 读写，单向遍历                       | `forward_list`           |
| **双向迭代器**      | 读写，双向遍历（`++`、`--`）         | `list`、`set`、`map`     |
| **随机访问迭代器**  | 读写，支持随机访问（`+n`、`[]`等）   | `vector`、`deque`、`array` |

#### 迭代器的基本操作
不同迭代器支持的操作符如下：

| 操作符                 | 功能描述       | 支持的迭代器类型       |
| ------------------- | ---------- | -------------- |
| `*iter`             | 解引用元素      | 输入、输出、正向、双向、随机 |
| `++iter` / `iter++` | 递增迭代器      | 所有迭代器          |
| `--iter` / `iter--` | 递减迭代器      | 双向、随机访问        |
| `iter + n`          | 向前跳跃`n`个元素 | 随机访问           |
| `iter - n`          | 向后跳跃`n`个元素 | 随机访问           |
| `iter1 == iter2`    | 判断是否指向同一位置 | 所有迭代器          |
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 3, 5, 7, 9};
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        *it += 10;  // 修改元素值
    }
    // 输出：11 13 15 17 19
    for (int num : vec) {
        std::cout << num << " ";
    }
    return 0;
}
```

### 迭代器的优势与必要性

#### 对比直接`for`循环

| **场景**      | **迭代器的优势**     | **直接`for`循环的不足** |
| ----------- | -------------- | ---------------- |
| 多容器类型支持     | 统一接口，代码通用      | 仅适用于特定容器         |
| 复杂遍历（反向、过滤） | 支持反向迭代器、过滤适配器  | 需手动实现，代码冗余       |
| 算法与容器解耦     | STL算法可复用       | 需为不同容器重写逻辑       |
| 安全性         | 类型安全，部分实现有边界检查 | 易发生越界或类型错误       |
| 现代语法支持      | 底层支持范围`for`循环  | 无法直接支持           |

#### 核心优势
1. **容器无关性**：同一算法适用于`vector`、`list`等不同容器。
2. **灵活操作**：支持反向遍历、常量访问等复杂操作。
3. **安全性**：通过类型检查和边界保护减少错误。
4. **性能优化**：编译器生成的代码效率接近原生指针。