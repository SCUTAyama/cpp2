- 原因：
	运算符重载显然常涉及到数据修改，如果数据放到private区，就只能靠public提供的接口访问，不必要的操作过多，故重载时多用成员或友元
- 注意：
	成员函数有this指针，友元函数没有
- 对比：

| **特性** | **成员函数**              | **友元函数**                |
| ------ | --------------------- | ----------------------- |
| 参数数量   | 少一个（隐含`this`）         | 显式所有参数                  |
| 左操作数类型 | 必须是当前类实例              | 任意类型                    |
| 隐式转换支持 | 仅右操作数                 | 左、右操作数均可                |
| 必须使用场景 | `=`, `[]`, `->`, `()` | 左操作数非当前类（如`<<`、`>>`）    |
| 对称性支持  | 有限（依赖构造函数）            | 强（可自由处理两侧类型）            |
| 所属     | 是类的成员函数               | 不是                      |
| 适用场景   | 修改当前对象的运算符（`+=`, `=`） | 对称运算符（`+`, `<<`）、混合类型操作 |


- 具体上：
	- 参数数量上：
		`A operator+(const A& other) const;`
		`friend A operator+(const A& input1, const A& input2) ;`
		（补：因为友元函数不是成员函数，无`self`指针，其不能像随手给传参补`const`一样补成常函数（尾缀`const`））
	- 左操作类型上：
		事实上编译器会对运算符进行进一步解释，具体情况见附图
		因而能感受到对于成员函数，因为是在调用左操作数的方法，故对其类型进行了固定
	- 隐式转换上
		由于成员函数是在调用左操作数的类的方法，故显然不能在这同时将其类别转变
	- 必须使用场景上
		必须使用成员函数时，多是其必须牵及`self`指针

| **运算符类型** | **成员函数重载**                                             | **友元函数重载**                                     |
| --------- | ------------------------------------------------------ | ---------------------------------------------- |
| **一元运算符** | `Object.operator op()`<br>（无参数，`this`传递）               | `operator op(Object)`<br>（1个参数，显式传递）           |
| **二元运算符** | `ObjectL.operator op(ObjectR)`<br>（1个参数，左操作数由`this`传递） | `operator op(ObjectL, ObjectR)`<br>（2个参数，显式传递） |
	