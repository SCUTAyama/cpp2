- 基类成员在所有派生类中具有作用域，被派生类屏蔽的基类数据成员不可见，但不等千不存在
- 如果想调用基类成员就需要调到它的作用域，也就是`b.A::funcA()`
- 派生类是在基类的基础上定义的。类定义仅说明其构成规则。在对象定义时，系统才会建立相应的存储空间。派生类对象的成员由基类定义的成员和自身定义的成员组成，成员访问特性和类继承性质不影响存储空间的建立。类成员访问特性和类继承性质决定类成员的作用域和可见性。在类层次体系中，只要访问特性和继承性质允许，派生类对基类的所有成员都可见，但基类对派生类的自定义成员一无所知。这说明基类成员的作用域从被说明时开始，一直延伸到它的所有派生类。即使因为访问特性或继承关系约束而被屏蔽，在派生类中不可见，但它们的作用域依然有效。
- 一方面我们可以用成员函数访问了派生类继承基类的私有数据成员。另外，私有继承的派生类可以通过访问声明调整对基类成员的访问权限，这也说明了不论采用何种继承方式，基类成员在派生类中都具有作用域。相反，由于继承关系的非对称性，基类不具备派生类中所定义的成员的作用域。同样道理，若派生类定义了与基类同名的成员，尽管基类的同名成员在派生类中被屏蔽（不可见），但它不能被覆盖和取代，作用域依然有效。因此，我们可以通过作用域运算符指定访问基类的同名成员。