- 基类私有成员的存在
	尽管继承时派生类不能访问基类的私有成员，这并不代表其不会被继承到派生类中去
	基类的私有成员在派生类被实例化时仍会被分配私有成员对应的内存
- 访问
	1. 参见[[2.1 可见性与作用域]]
	2. 访问声明
		若A中有public函数`func()`，B从A私有继承，则Bpublic区再声明`A::func()`就可用`objB.func()`调用
		这其实和上一条是一样的
		格式是`baseClassName::memberName`
		不可在派生类中再声明其类型（如是`A::func()`而不是`void A::func()`）
		派生类中基类成员的访问权限只能恢复到基类原有的权限，既不能提升（更开放）也不能降低（更严格）
			如`protected`只能回复到`pretected`，声明不能使之成为`public`或`private`
		重载函数情况：
			1.  若所有重载在基类同访问域内则可只声明函数名以改变所有同名函数（如有多个`func()`，则声明`using A::func`即可）
			2. 不同访问域的重载函数名不能用于访问声明（二义性）
			3. 派生类和基类名字相同的成员不可调整访问权限
		**注**：好像`A::func()`太老被弃用了，现在改用了`using A::get_XY`