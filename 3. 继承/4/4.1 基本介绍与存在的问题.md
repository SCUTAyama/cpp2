- 语法：
	`class C : public A, public B{...};`
- 构造顺序
	多个基类的派生类构造函数可以通过继承路径调用基类构造函数，执行顺序与单继承构造函数情况类似：先执行基类构造函数，再执行子对象构造函数，最后执行本身的构造函数。由千多继承的派生类有多个直接基类，因此，它们的构造函数执行顺序取决千定义派生类时指定的各个继承基类的顺序，而与派生类构造函数成员参数初始式列表中给定的基类顺序无关。

### 存在的问题：菱形继承问题
当出现D继承自B,C，B,C继承自A时会出现派生类包含多个公共基类的情况，如
```cpp
class B { public: B() { cout << "B构造\n"; } int x};  
class B1 : public B { public: void getData() { ... } };  
class B2 : public B { public: void getData() { ... } };  
class D : public B1, public B2 { ... };

Derived d;
```
会出现以下问题：
1. 数据冗余：
	`D` 类对象会包含两个 `B` 的实例：`B1::x` 和 `B2::x`，这二者虽然都来自与D，相互之间却只是重名的从D创建时的复制关系，可以被各自修改
    访问 `x` 时需显式指定路径（如 `d.B1::x` 或 `d.B2::x`）。
    这显然既麻烦又不符合大部分显示含义
    下一节注意“非虚基类”部分
2. 时刻指定作用域
	多个基类有同名成员函数或数据成员，派生类无法直接确定调用哪个版本。
	`d.getData()`必须添加作用域为如`d.Base1::getData()`
3. 构造函数被重复调用
	如这里d的创建会调用B的构造函数两次